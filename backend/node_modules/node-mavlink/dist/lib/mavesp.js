"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MavEsp8266 = void 0;
const events_1 = require("events");
const dgram_1 = require("dgram");
const stream_1 = require("stream");
const mavlink_1 = require("./mavlink");
const mavlink_2 = require("./mavlink");
const utils_1 = require("./utils");
/**
 * Encapsulation of communication with MavEsp8266
 */
class MavEsp8266 extends events_1.EventEmitter {
    constructor() {
        super();
        this.ip = '';
        this.sendPort = 14555;
        this.seq = 0;
        this.input = new stream_1.PassThrough();
        this.processIncommingUDPData = this.processIncommingUDPData.bind(this);
        this.processIncommingPacket = this.processIncommingPacket.bind(this);
        // Create the reader as usual by piping the source stream through the splitter
        // and packet parser
        const reader = this.input
            .pipe(new mavlink_1.MavLinkPacketSplitter())
            .pipe(new mavlink_1.MavLinkPacketParser());
        reader.on('data', this.processIncommingPacket);
    }
    /**
     * Start communication with the controller via MAVESP2866
     *
     * @param receivePort port to receive messages on (default: 14550)
     * @param sendPort port to send messages to (default: 14555)
     */
    start(receivePort = 14550, sendPort = 14555) {
        return __awaiter(this, void 0, void 0, function* () {
            this.sendPort = sendPort;
            // Create a UDP socket
            this.socket = dgram_1.createSocket({ type: 'udp4', reuseAddr: true });
            this.socket.on('message', this.processIncommingUDPData);
            // Start listening on the socket
            return new Promise((resolve, reject) => {
                this.socket.bind(receivePort, () => {
                    // Wait for the first package to be returned to read the ip address
                    // of the controller
                    utils_1.waitFor(() => this.ip !== '')
                        .then(() => { resolve(this.ip); })
                        .catch(e => { reject(e); });
                });
            });
        });
    }
    /**
     * Send a packet
     *
     * @param msg message to send
     * @param protocol protocol used to encode the buffer (default: MavLinkProtocolV1)
     */
    send(msg, protocol = new mavlink_2.MavLinkProtocolV1()) {
        const buffer = protocol.serialize(msg, this.seq++);
        this.seq &= 255;
        this.socket.send(buffer, this.sendPort, this.ip);
    }
    processIncommingUDPData(buffer, metadata) {
        // store the remote ip address
        if (this.ip === '')
            this.ip = metadata.address;
        // pass on the data to the input stream
        this.input.write(buffer);
    }
    processIncommingPacket(packet) {
        // let the user know we received the packet
        this.emit('data', packet);
    }
}
exports.MavEsp8266 = MavEsp8266;
