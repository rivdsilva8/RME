/// <reference types="node" />
import { Transform, TransformCallback, Writable } from 'stream';
import { uint8_t, uint16_t } from './types';
export declare const MAVLINK_CHECKSUM_LENGTH = 2;
/**
 * Header definition of the MavLink packet
 */
export declare class MavLinkPacketHeader {
    magic: number;
    payloadLength: uint8_t;
    incompatibilityFlags: uint8_t;
    compatibilityFlags: uint8_t;
    seq: uint8_t;
    sysid: uint8_t;
    compid: uint8_t;
    msgid: uint8_t;
}
/**
 * Field definition
 */
export declare class MavLinkPacketField {
    readonly name: string;
    readonly type: string;
    readonly length: number;
    readonly offset: number;
    readonly extension: boolean;
    readonly size: number;
    /**
     * @param name name of the field
     * @param offset field offset in the payload
     * @param extension true if it is an extension field, false otherwise
     * @param size size of either the field or the size of an element in the array if it is an array field
     * @param type type of the field (ends with [] if it is an array field)
     * @param length for array fields this is the length of the array
     */
    constructor(name: any, offset: any, extension: any, size: any, type: any, length?: number);
}
/**
 * Base class for all data classes
 */
export declare abstract class MavLinkData {
    static MSG_ID: number;
    static MSG_NAME: string;
    static PAYLOAD_LENGTH: number;
    static MAGIC_NUMBER: number;
    static FIELDS: MavLinkPacketField[];
}
interface MavLinkDataConstructor<T extends MavLinkData> {
    MSG_ID: number;
    MSG_NAME: string;
    PAYLOAD_LENGTH: number;
    MAGIC_NUMBER: number;
    FIELDS: MavLinkPacketField[];
    new (): T;
}
/**
 * Base class for protocols
 *
 * Implements common functionality like getting the CRC and deserializing
 * data classes from the given payload buffer
 */
export declare abstract class MavLinkProtocol {
    static NAME: string;
    static START_BYTE: number;
    static PAYLOAD_OFFSET: number;
    static SYS_ID: uint8_t;
    static COMP_ID: uint8_t;
    /**
     * Serialize a message to a buffer
     */
    abstract serialize(message: MavLinkData, seq: uint8_t): Buffer;
    /**
     * Deserialize packet header
     */
    abstract header(buffer: any): MavLinkPacketHeader;
    /**
     * Deserialize packet checksum
     */
    abstract crc(buffer: any): uint16_t;
    /**
     * Extract payload buffer
     *
     * The returned payload buffer needs to be long enough to read all
     * the fields, including extensions that are sometimes not being sent
     * from the transmitting system.
     */
    abstract payload(buffer: Buffer, header: MavLinkPacketHeader): Buffer;
    /**
     * Deserialize payload into actual data class
     */
    data<T extends MavLinkData>(payload: Buffer, clazz: MavLinkDataConstructor<T>): T;
}
/**
 * MavLink Protocol V1
 */
export declare class MavLinkProtocolV1 extends MavLinkProtocol {
    sysid: uint8_t;
    compid: uint8_t;
    static NAME: string;
    static START_BYTE: number;
    static PAYLOAD_OFFSET: number;
    constructor(sysid?: uint8_t, compid?: uint8_t);
    serialize(message: MavLinkData, seq: number): Buffer;
    header(buffer: Buffer): MavLinkPacketHeader;
    /**
     * Deserialize packet checksum
     */
    crc(buffer: Buffer): uint16_t;
    payload(buffer: Buffer, header: MavLinkPacketHeader): Buffer;
}
/**
 * MavLink Protocol V2
 */
export declare class MavLinkProtocolV2 extends MavLinkProtocol {
    sysid: uint8_t;
    compid: uint8_t;
    static NAME: string;
    static START_BYTE: number;
    static PAYLOAD_OFFSET: number;
    static SIGNATURE_LENGTH: number;
    static INCOMPATIBILITY_FLAGS: uint8_t;
    static COMPATIBILITY_FLAGS: uint8_t;
    static readonly IFLAG_SIGNED = 1;
    constructor(sysid?: uint8_t, compid?: uint8_t);
    serialize(message: MavLinkData, seq: number): Buffer;
    private calculateTruncatedPayloadLength;
    header(buffer: Buffer): MavLinkPacketHeader;
    /**
     * Deserialize packet checksum
     */
    crc(buffer: Buffer): uint16_t;
    payload(buffer: Buffer, header: MavLinkPacketHeader): Buffer;
    signature(buffer: Buffer, header: MavLinkPacketHeader): MavLinkPacketSignature;
}
/**
 * MavLink packet signature definition
 */
export declare class MavLinkPacketSignature {
    readonly packetBuffer: Buffer;
    readonly linkId: uint8_t;
    readonly timestamp: number;
    readonly signature: string;
    constructor(packetBuffer: Buffer, linkId: uint8_t, timestamp: number, signature: string);
    /**
     * Calculates signature of the packet buffer using the provided secret.
     * The secret is converted to a hash using the sha256 algorithm which matches
     * the way Mission Planner creates keys.
     *
     * @param secret secret to generate the key
     * @returns calculated signature value
     */
    calculate(secret: string): string;
    /**
     * Checks the signature of the packet buffer against a given secret
     * The secret is converted to a hash using the sha256 algorithm which matches
     * the way Mission Planner creates keys.
     *
     * @param secret secret to generate the key
     * @returns true if the signature matches, false otherwise
     */
    matches(secret: string): boolean;
    toString(): string;
}
/**
 * MavLink packet definition
 */
export declare class MavLinkPacket {
    readonly buffer: Buffer;
    readonly header: MavLinkPacketHeader;
    readonly payload: Buffer;
    readonly crc: uint16_t;
    readonly protocol: MavLinkProtocol;
    readonly signature: MavLinkPacketSignature;
    constructor(buffer: Buffer, header?: MavLinkPacketHeader, payload?: Buffer, crc?: uint16_t, protocol?: MavLinkProtocol, signature?: MavLinkPacketSignature);
    debug(): string;
    private signatureToString;
}
/**
 * A transform stream that splits the incomming data stream into chunks containing full MavLink messages
 */
export declare class MavLinkPacketSplitter extends Transform {
    private buffer;
    _transform(chunk: Buffer, encoding: any, callback: TransformCallback): void;
    /**
     * Checks if the buffer contains the entire message with signature
     *
     * @param buffer buffer with the message
     */
    private isV2Signed;
}
/**
 * A transform stream that takes a buffer with data and converts it to MavLinkPacket object
 */
export declare class MavLinkPacketParser extends Transform {
    constructor(opts?: {});
    private getProtocol;
    _transform(chunk: Buffer, encoding: any, callback: TransformCallback): void;
}
export declare function send(stream: Writable, msg: MavLinkData, protocol?: MavLinkProtocol): Promise<unknown>;
export {};
