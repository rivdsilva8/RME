"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.send = exports.MavLinkPacketParser = exports.MavLinkPacketSplitter = exports.MavLinkPacket = exports.MavLinkPacketSignature = exports.MavLinkProtocolV2 = exports.MavLinkProtocolV1 = exports.MavLinkProtocol = exports.MavLinkData = exports.MavLinkPacketField = exports.MavLinkPacketHeader = exports.MAVLINK_CHECKSUM_LENGTH = void 0;
const stream_1 = require("stream");
const crypto_1 = require("crypto");
const utils_1 = require("./utils");
const magic_numbers_1 = require("./magic-numbers");
const serialization_1 = require("./serialization");
exports.MAVLINK_CHECKSUM_LENGTH = 0x02;
/**
 * Header definition of the MavLink packet
 */
class MavLinkPacketHeader {
    constructor() {
        this.magic = 0;
        this.payloadLength = 0;
        this.incompatibilityFlags = 0;
        this.compatibilityFlags = 0;
        this.seq = 0;
        this.sysid = 0;
        this.compid = 0;
        this.msgid = 0;
    }
}
exports.MavLinkPacketHeader = MavLinkPacketHeader;
/**
 * Field definition
 */
class MavLinkPacketField {
    /**
     * @param name name of the field
     * @param offset field offset in the payload
     * @param extension true if it is an extension field, false otherwise
     * @param size size of either the field or the size of an element in the array if it is an array field
     * @param type type of the field (ends with [] if it is an array field)
     * @param length for array fields this is the length of the array
     */
    constructor(name, offset, extension, size, type, length = 0) {
        this.name = name;
        this.offset = offset;
        this.type = type;
        this.length = length;
        this.extension = extension;
        this.size = size;
    }
}
exports.MavLinkPacketField = MavLinkPacketField;
/**
 * Base class for all data classes
 */
class MavLinkData {
}
exports.MavLinkData = MavLinkData;
// static fields overriden by descendants of MavLinkData
MavLinkData.MSG_ID = -1;
MavLinkData.MSG_NAME = '';
MavLinkData.PAYLOAD_LENGTH = 0;
MavLinkData.MAGIC_NUMBER = 0;
MavLinkData.FIELDS = [];
/**
 * Base class for protocols
 *
 * Implements common functionality like getting the CRC and deserializing
 * data classes from the given payload buffer
 */
class MavLinkProtocol {
    /**
     * Deserialize payload into actual data class
     */
    data(payload, clazz) {
        const instance = new clazz();
        clazz.FIELDS.forEach(field => {
            const deserialize = serialization_1.DESERIALIZERS[field.type];
            if (!deserialize) {
                throw new Error(`Unknown field type ${field.type}`);
            }
            instance[field.name] = deserialize(payload, field.offset, field.length);
        });
        return instance;
    }
}
exports.MavLinkProtocol = MavLinkProtocol;
MavLinkProtocol.NAME = 'unknown';
MavLinkProtocol.START_BYTE = 0;
MavLinkProtocol.PAYLOAD_OFFSET = 0;
MavLinkProtocol.SYS_ID = 254;
MavLinkProtocol.COMP_ID = 1;
/**
 * MavLink Protocol V1
 */
class MavLinkProtocolV1 extends MavLinkProtocol {
    constructor(sysid = MavLinkProtocol.SYS_ID, compid = MavLinkProtocol.COMP_ID) {
        super();
        this.sysid = sysid;
        this.compid = compid;
    }
    serialize(message, seq) {
        const definition = message.constructor;
        const buffer = Buffer.from(new Uint8Array(MavLinkProtocolV1.PAYLOAD_OFFSET + definition.PAYLOAD_LENGTH + exports.MAVLINK_CHECKSUM_LENGTH));
        // serialize header
        buffer.writeUInt8(MavLinkProtocolV1.START_BYTE, 0);
        buffer.writeUInt8(definition.PAYLOAD_LENGTH, 1);
        buffer.writeUInt8(seq, 2);
        buffer.writeUInt8(this.sysid, 3);
        buffer.writeUInt8(this.compid, 4);
        buffer.writeUInt8(definition.MSG_ID, 5);
        // serialize fields
        definition.FIELDS.forEach(field => {
            const serialize = serialization_1.SERIALIZERS[field.type];
            if (!serialize)
                throw new Error(`Unknown field type ${field.type}: serializer not found`);
            serialize(message[field.name], buffer, field.offset + MavLinkProtocolV1.PAYLOAD_OFFSET, field.length);
        });
        // serialize checksum
        const crc = utils_1.x25crc(buffer, 1, 2, definition.MAGIC_NUMBER);
        buffer.writeUInt16LE(crc, buffer.length - 2);
        return buffer;
    }
    header(buffer) {
        const startByte = buffer.readUInt8(0);
        if (startByte !== MavLinkProtocolV1.START_BYTE) {
            throw new Error(`Invalid start byte (expected: ${MavLinkProtocolV1.START_BYTE}, got ${startByte})`);
        }
        const result = new MavLinkPacketHeader();
        result.magic = startByte;
        result.payloadLength = buffer.readUInt8(1);
        result.seq = buffer.readUInt8(2);
        result.sysid = buffer.readUInt8(3);
        result.compid = buffer.readUInt8(4);
        result.msgid = buffer.readUInt8(5);
        return result;
    }
    /**
     * Deserialize packet checksum
     */
    crc(buffer) {
        const plen = buffer.readUInt8(1);
        return buffer.readUInt16LE(MavLinkProtocolV1.PAYLOAD_OFFSET + plen);
    }
    payload(buffer, header) {
        const payload = buffer.slice(MavLinkProtocolV1.PAYLOAD_OFFSET, header.payloadLength);
        const padding = Buffer.from(new Uint8Array(255 - payload.length));
        return Buffer.concat([payload, padding]);
    }
}
exports.MavLinkProtocolV1 = MavLinkProtocolV1;
MavLinkProtocolV1.NAME = 'MAV_V1';
MavLinkProtocolV1.START_BYTE = 0xFE;
MavLinkProtocolV1.PAYLOAD_OFFSET = 6;
/**
 * MavLink Protocol V2
 */
class MavLinkProtocolV2 extends MavLinkProtocol {
    constructor(sysid = MavLinkProtocol.SYS_ID, compid = MavLinkProtocol.COMP_ID) {
        super();
        this.sysid = sysid;
        this.compid = compid;
    }
    serialize(message, seq) {
        const definition = message.constructor;
        const buffer = Buffer.from(new Uint8Array(MavLinkProtocolV2.PAYLOAD_OFFSET + definition.PAYLOAD_LENGTH + exports.MAVLINK_CHECKSUM_LENGTH));
        buffer.writeUInt8(MavLinkProtocolV2.START_BYTE, 0);
        buffer.writeUInt8(MavLinkProtocolV2.INCOMPATIBILITY_FLAGS, 2);
        buffer.writeUInt8(MavLinkProtocolV2.COMPATIBILITY_FLAGS, 3);
        buffer.writeUInt8(seq, 4);
        buffer.writeUInt8(this.sysid, 5);
        buffer.writeUInt8(this.compid, 6);
        buffer.writeUIntLE(definition.MSG_ID, 7, 3);
        definition.FIELDS.forEach(field => {
            const serialize = serialization_1.SERIALIZERS[field.type];
            if (!serialize)
                throw new Error(`Unknown field type ${field.type}: serializer not found`);
            serialize(message[field.name], buffer, field.offset + MavLinkProtocolV2.PAYLOAD_OFFSET, field.length);
        });
        // calculate actual truncated payload length
        const payloadLength = this.calculateTruncatedPayloadLength(buffer);
        buffer.writeUInt8(payloadLength, 1);
        // slice out the message buffer
        const result = buffer.slice(0, MavLinkProtocolV2.PAYLOAD_OFFSET + payloadLength + exports.MAVLINK_CHECKSUM_LENGTH);
        const crc = utils_1.x25crc(result, 1, 2, definition.MAGIC_NUMBER);
        result.writeUInt16LE(crc, result.length - exports.MAVLINK_CHECKSUM_LENGTH);
        return result;
    }
    calculateTruncatedPayloadLength(buffer) {
        let result = buffer.length;
        for (let i = buffer.length - exports.MAVLINK_CHECKSUM_LENGTH - 1; i >= MavLinkProtocolV2.PAYLOAD_OFFSET; i--) {
            result = i;
            if (buffer[i] !== 0) {
                result++;
                break;
            }
        }
        return result - MavLinkProtocolV2.PAYLOAD_OFFSET;
    }
    header(buffer) {
        const startByte = buffer.readUInt8(0);
        if (startByte !== MavLinkProtocolV2.START_BYTE) {
            throw new Error(`Invalid start byte (expected: ${MavLinkProtocolV2.START_BYTE}, got ${startByte})`);
        }
        const result = new MavLinkPacketHeader();
        result.magic = startByte;
        result.payloadLength = buffer.readUInt8(1);
        result.incompatibilityFlags = buffer.readUInt8(2);
        result.compatibilityFlags = buffer.readUInt8(3);
        result.seq = buffer.readUInt8(4);
        result.sysid = buffer.readUInt8(5);
        result.compid = buffer.readUInt8(6);
        result.msgid = buffer.readUIntLE(7, 3);
        return result;
    }
    /**
     * Deserialize packet checksum
     */
    crc(buffer) {
        const plen = buffer.readUInt8(1);
        return buffer.readUInt16LE(MavLinkProtocolV2.PAYLOAD_OFFSET + plen);
    }
    payload(buffer, header) {
        const payload = buffer.slice(MavLinkProtocolV2.PAYLOAD_OFFSET, header.payloadLength);
        const padding = Buffer.from(new Uint8Array(255 - payload.length));
        return Buffer.concat([payload, padding]);
    }
    signature(buffer, header) {
        if (header.incompatibilityFlags & MavLinkProtocolV2.IFLAG_SIGNED) {
            const signatureOffset = MavLinkProtocolV2.PAYLOAD_OFFSET + header.payloadLength + exports.MAVLINK_CHECKSUM_LENGTH;
            return new MavLinkPacketSignature(buffer, buffer.readUInt8(signatureOffset), buffer.readUIntLE(signatureOffset + 1, 6), buffer.slice(signatureOffset + 7, buffer.length).toString('hex'));
        }
        else {
            return null;
        }
    }
}
exports.MavLinkProtocolV2 = MavLinkProtocolV2;
MavLinkProtocolV2.NAME = 'MAV_V2';
MavLinkProtocolV2.START_BYTE = 0xFD;
MavLinkProtocolV2.PAYLOAD_OFFSET = 10;
MavLinkProtocolV2.SIGNATURE_LENGTH = 13;
MavLinkProtocolV2.INCOMPATIBILITY_FLAGS = 0;
MavLinkProtocolV2.COMPATIBILITY_FLAGS = 0;
MavLinkProtocolV2.IFLAG_SIGNED = 0x01;
/**
 * MavLink packet signature definition
 */
class MavLinkPacketSignature {
    constructor(packetBuffer, linkId, timestamp, signature) {
        this.packetBuffer = packetBuffer;
        this.linkId = linkId;
        this.timestamp = timestamp;
        this.signature = signature;
    }
    /**
     * Calculates signature of the packet buffer using the provided secret.
     * The secret is converted to a hash using the sha256 algorithm which matches
     * the way Mission Planner creates keys.
     *
     * @param secret secret to generate the key
     * @returns calculated signature value
     */
    calculate(secret) {
        const key = crypto_1.createHash('sha256')
            .update(secret)
            .digest();
        const hash = crypto_1.createHash('sha256')
            .update(key)
            .update(this.packetBuffer.slice(0, this.packetBuffer.length - 6))
            .digest('hex')
            .substr(0, 12);
        return hash;
    }
    /**
     * Checks the signature of the packet buffer against a given secret
     * The secret is converted to a hash using the sha256 algorithm which matches
     * the way Mission Planner creates keys.
     *
     * @param secret secret to generate the key
     * @returns true if the signature matches, false otherwise
     */
    matches(secret) {
        return this.calculate(secret) === this.signature;
    }
    toString() {
        return `linkid: ${this.linkId}, `
            + `timestamp ${this.timestamp}, `
            + `signature ${this.signature}`;
    }
}
exports.MavLinkPacketSignature = MavLinkPacketSignature;
/**
 * MavLink packet definition
 */
class MavLinkPacket {
    constructor(buffer, header = new MavLinkPacketHeader(), payload = Buffer.from(new Uint8Array(255)), crc = 0, protocol = new MavLinkProtocolV1(), signature = null) {
        this.buffer = buffer;
        this.header = header;
        this.payload = payload;
        this.crc = crc;
        this.protocol = protocol;
        this.signature = signature;
    }
    debug() {
        return 'Packet ('
            + `proto: ${this.protocol.constructor['NAME']}, `
            + `sysid: ${this.header.sysid}, `
            + `compid: ${this.header.compid}, `
            + `msgid: ${this.header.msgid}, `
            + `seq: ${this.header.seq}, `
            + `plen: ${this.header.payloadLength}, `
            + `crc: ${this.crc.toString(16).padStart(2, '0')}`
            + this.signatureToString(this.signature)
            + ')';
    }
    signatureToString(signature) {
        return signature ? `, ${signature.toString()}` : '';
    }
}
exports.MavLinkPacket = MavLinkPacket;
/**
 * A transform stream that splits the incomming data stream into chunks containing full MavLink messages
 */
class MavLinkPacketSplitter extends stream_1.Transform {
    constructor() {
        super(...arguments);
        this.buffer = Buffer.from([]);
    }
    _transform(chunk, encoding, callback) {
        this.buffer = Buffer.concat([this.buffer, chunk]);
        while (true) {
            let Protocol = null;
            // check for start byte
            let startByteFirstOffset = this.buffer.indexOf(MavLinkProtocolV1.START_BYTE);
            if (startByteFirstOffset >= 0) {
                Protocol = MavLinkProtocolV1;
            }
            else {
                startByteFirstOffset = this.buffer.indexOf(MavLinkProtocolV2.START_BYTE);
                if (startByteFirstOffset >= 0) {
                    Protocol = MavLinkProtocolV2;
                }
                else {
                    // start byte not found - skipping
                    break;
                }
            }
            // fast-forward the buffer to the first start byte
            if (startByteFirstOffset > 0) {
                this.buffer = this.buffer.slice(startByteFirstOffset);
            }
            // check if the buffer contains at least the minumum size of data
            if (this.buffer.length < Protocol.PAYLOAD_OFFSET + exports.MAVLINK_CHECKSUM_LENGTH) {
                // current buffer shorter than the shortest message - skipping
                break;
            }
            // check if the current buffer contains the entire message
            const payloadLength = this.buffer.readUInt8(1);
            const expectedBufferLength = Protocol.PAYLOAD_OFFSET
                + payloadLength
                + exports.MAVLINK_CHECKSUM_LENGTH
                + (this.isV2Signed(this.buffer) ? MavLinkProtocolV2.SIGNATURE_LENGTH : 0);
            if (this.buffer.length < expectedBufferLength) {
                // current buffer is not fully retrieved yet - skipping
                break;
            }
            // retrieve the buffer based on payload size
            const buffer = this.buffer.slice(0, expectedBufferLength);
            // truncate the buffer to remove the current message
            this.buffer = this.buffer.slice(expectedBufferLength);
            // validate message checksum including the magic byte
            const protocol = new Protocol();
            const header = protocol.header(buffer);
            const magic = magic_numbers_1.MSG_ID_MAGIC_NUMBER[header.msgid];
            if (magic) {
                const crc = protocol.crc(buffer);
                const trim = this.isV2Signed(buffer)
                    ? MavLinkProtocolV2.SIGNATURE_LENGTH + exports.MAVLINK_CHECKSUM_LENGTH
                    : exports.MAVLINK_CHECKSUM_LENGTH;
                const crc2 = utils_1.x25crc(buffer, 1, trim, magic);
                if (crc === crc2) {
                    // CRC matches - accept this packet
                    this.push(buffer);
                }
                else {
                    // CRC mismatch - skip packet
                    console.error('CRC error; expected', crc2, `(0x${crc2.toString(16).padStart(4, '0')})`, 'got', crc, `(0x${crc.toString(16).padStart(4, '0')})`, '; msgid:', header.msgid, ', magic:', magic);
                    utils_1.dump(buffer);
                }
            }
            else {
                // this meessage has not been generated - ignoring
                console.error(`Unknown message with id ${header.msgid} (magic number not found) - skipping`);
            }
        }
        callback(null);
    }
    /**
     * Checks if the buffer contains the entire message with signature
     *
     * @param buffer buffer with the message
     */
    isV2Signed(buffer) {
        const protocol = buffer.readUInt8(0);
        if (protocol === MavLinkProtocolV2.START_BYTE) {
            const flags = buffer.readUInt8(2);
            return !!(flags & MavLinkProtocolV2.IFLAG_SIGNED);
        }
    }
}
exports.MavLinkPacketSplitter = MavLinkPacketSplitter;
/**
 * A transform stream that takes a buffer with data and converts it to MavLinkPacket object
 */
class MavLinkPacketParser extends stream_1.Transform {
    constructor(opts = {}) {
        super(Object.assign(Object.assign({}, opts), { objectMode: true }));
    }
    getProtocol(buffer) {
        const startByte = buffer.readUInt8(0);
        switch (startByte) {
            case MavLinkProtocolV1.START_BYTE:
                return new MavLinkProtocolV1();
            case MavLinkProtocolV2.START_BYTE:
                return new MavLinkProtocolV2();
            default:
                throw new Error(`Unknown protocol '${startByte.toString(16).padStart(2, '0')}'`);
        }
    }
    _transform(chunk, encoding, callback) {
        const protocol = this.getProtocol(chunk);
        const header = protocol.header(chunk);
        const payload = protocol.payload(chunk, header);
        const crc = protocol.crc(chunk);
        const signature = protocol instanceof MavLinkProtocolV2
            ? protocol.signature(chunk, header)
            : null;
        const packet = new MavLinkPacket(chunk, header, payload, crc, protocol, signature);
        callback(null, packet);
    }
}
exports.MavLinkPacketParser = MavLinkPacketParser;
let seq = 0;
function send(stream, msg, protocol = new MavLinkProtocolV1()) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            const buffer = protocol.serialize(msg, seq++);
            seq &= 255;
            stream.write(buffer, err => {
                if (err)
                    reject(err);
                else
                    resolve(buffer.length);
            });
        });
    });
}
exports.send = send;
