"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitFor = exports.sleep = exports.dump = exports.x25crc = void 0;
function x25crc(buffer, start = 0, trim = 0, magic = null) {
    let crc = 0xffff;
    for (let i = start; i < buffer.length - trim; i++) {
        const byte = buffer[i];
        let tmp = (byte & 0xff) ^ (crc & 0xff);
        tmp ^= tmp << 4;
        tmp &= 0xff;
        crc = (crc >> 8) ^ (tmp << 8) ^ (tmp << 3) ^ (tmp >> 4);
        crc &= 0xffff;
    }
    if (magic !== null) {
        let tmp = (magic & 0xff) ^ (crc & 0xff);
        tmp ^= tmp << 4;
        tmp &= 0xff;
        crc = (crc >> 8) ^ (tmp << 8) ^ (tmp << 3) ^ (tmp >> 4);
        crc &= 0xffff;
    }
    return crc;
}
exports.x25crc = x25crc;
function dump(buffer, lineWidth = 28) {
    const line = [];
    for (let i = 0; i < buffer.length; i++) {
        line.push(buffer[i].toString(16).padStart(2, '0') + ' ');
        if (line.length === lineWidth) {
            console.error(line.join(' '));
            line.length = 0;
        }
    }
    if (line.length > 0) {
        console.error(line.join(' '));
    }
}
exports.dump = dump;
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
exports.sleep = sleep;
function waitFor(cb, timeout = 10000, interval = 100) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            const timeoutTimer = setTimeout(() => {
                cleanup();
                reject('Timeout');
            }, timeout);
            const intervalTimer = setInterval(() => {
                const result = cb();
                if (result) {
                    cleanup();
                    resolve(result);
                }
            });
            const cleanup = () => {
                clearTimeout(timeoutTimer);
                clearTimeout(intervalTimer);
            };
        });
    });
}
exports.waitFor = waitFor;
